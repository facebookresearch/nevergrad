import numpy as np


class SequentialQuadraticExploitationSearch:
    def __init__(self, budget):
        self.budget = budget
        self.dimension = 5  # Dimensionality of the BBOB test suite
        self.lower_bound = -5.0
        self.upper_bound = 5.0

    def __call__(self, func):
        self.f_opt = np.inf
        self.x_opt = None

        # Start with random initialization
        current_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dimension)
        current_fitness = func(current_position)
        self.update_optimum(current_position, current_fitness)

        # Control parameters
        delta = 0.5  # Initial step size for exploratory moves
        alpha = 0.5  # Step size reduction factor
        epsilon = 1e-6  # Convergence criterion

        iteration = 1
        while iteration < self.budget:
            # Create a set of points around the current position
            points = np.array(
                [current_position + delta * np.eye(self.dimension)[:, i] for i in range(self.dimension)]
                + [current_position - delta * np.eye(self.dimension)[:, i] for i in range(self.dimension)]
            )
            points = np.clip(points, self.lower_bound, self.upper_bound)

            # Evaluate the function at these points
            fitnesses = np.array([func(point) for point in points])

            # Approximate a quadratic model based on the current position and evaluated points
            A, b = self.fit_quadratic(current_position, points, fitnesses)
            if np.linalg.cond(A) < 1 / epsilon:  # Check conditioning to prevent bad fits
                # Update the position by moving opposite to the gradient implied by the quadratic model
                try:
                    step_direction = -np.linalg.solve(A, b)
                    new_position = current_position + step_direction
                    new_position = np.clip(new_position, self.lower_bound, self.upper_bound)
                    new_fitness = func(new_position)
                except np.linalg.LinAlgError:
                    new_position = current_position
                    new_fitness = current_fitness

                if new_fitness < current_fitness:
                    current_position, current_fitness = new_position, new_fitness
                    delta = min(delta / alpha, 1.0)  # Increase step size upon success
                else:
                    delta *= alpha  # Reduce step size upon failure

                self.update_optimum(current_position, current_fitness)
            iteration += 2 * self.dimension + 1

        return self.f_opt, self.x_opt

    def update_optimum(self, x, f):
        if f < self.f_opt:
            self.f_opt = f
            self.x_opt = x

    def fit_quadratic(self, center, points, fitnesses):
        # Fit a quadratic model to the points and their fitness values
        n = len(points)
        X = np.hstack([np.ones((n, 1)), points - center, ((points - center) ** 2)])
        coeffs = np.linalg.lstsq(X, fitnesses, rcond=None)[0]
        A = np.diag(coeffs[1 + self.dimension :])
        b = coeffs[1 : 1 + self.dimension]
        return A, b
